"""
Unit Tests for UserRepository

EDUCATIONAL NOTE FOR STUDENTS:
================================
Welcome to your first real test file! This file demonstrates professional
testing practices for a database repository class.

What You'll Learn:
------------------
1. AAA Pattern (Arrange-Act-Assert) - The fundamental structure of all tests
2. Testing CRUD operations (Create, Read, Update, Delete)
3. Testing edge cases (what happens when things go wrong?)
4. Testing security (password hashing)
5. Using fixtures for clean test setup
6. Parametrized tests for testing multiple scenarios efficiently

Repository Pattern:
-------------------
The repository pattern isolates database operations from business logic.
Think of UserRepository as a "librarian" for User data:
- You ask the librarian for data (get_user_by_email)
- You don't directly access the database (books)
- The librarian handles the messy details

Testing the repository ensures our "librarian" does their job correctly!

Author: Holiday Gifting Dashboard Team
Purpose: Educational testing example for CS students
"""

import pytest
import bcrypt
from app.repository import UserRepository
from app.models import User
from tests.fixtures.test_data import UserFactory


# =============================================================================
# TEST CLASS: User Creation
# =============================================================================

class TestUserCreation:
    """
    Tests for creating new users.

    LEARNING OBJECTIVE: Testing the "Create" in CRUD
    =================================================
    When testing creation, we verify:
    1. Object is created with correct data
    2. Object is saved to database (has an ID)
    3. Data integrity (passwords hashed, emails lowercase, etc.)
    4. Edge cases (empty strings, special characters, etc.)
    """

    def test_create_user_with_valid_data(self, db_session):
        """
        Test the happy path: creating a user with all valid data.

        PATTERN: AAA (Arrange-Act-Assert)
        ==================================
        Every good test follows this three-part structure:

        ARRANGE: Set up test data and preconditions
        ACT: Execute the function being tested
        ASSERT: Verify the expected outcome

        This makes tests easy to read and maintain!
        """
        # ARRANGE - Prepare test data
        email = "alice@example.com"
        name = "Alice Smith"
        password = "secure_password_123"

        # ACT - Execute the function under test
        user = UserRepository.create_user(db_session, email, name, password)

        # ASSERT - Verify the results
        assert user is not None, "User should be created"
        assert user.id is not None, "User should have an ID (auto-generated by database)"
        assert user.email == email, "User email should match what we provided"
        assert user.name == name, "User name should match what we provided"

    def test_create_user_hashes_password(self, db_session):
        """
        SECURITY TEST: Verify passwords are hashed, not stored in plain text.

        WHY THIS MATTERS:
        =================
        Storing plain-text passwords is a CATASTROPHIC security flaw.
        If the database is stolen, all passwords are exposed.

        Instead, we use bcrypt to create a one-way hash:
        - "password123" ‚Üí "$2b$12$EixZaYVK1fsbw1..."
        - Cannot reverse the hash to get original password
        - Even identical passwords create different hashes (salt)

        This test ensures we're following security best practices!
        """
        # Arrange
        plain_password = "my_secret_password"

        # Act
        user = UserRepository.create_user(
            db_session,
            email="security@test.com",
            name="Security Test",
            password=plain_password
        )

        # Assert: Password should be hashed, not plain text
        assert user.password_hash != plain_password, \
            "SECURITY FAILURE: Password stored in plain text!"

        assert len(user.password_hash) > 20, \
            "Password hash should be long (bcrypt hashes are ~60 characters)"

        assert user.password_hash.startswith("$2b$"), \
            "Should be a bcrypt hash (starts with $2b$)"

    def test_create_user_persists_to_database(self, db_session):
        """
        Test that created user actually exists in the database.

        LEARNING: Testing Persistence
        ==============================
        Creating an object in Python is different from saving it to a database.
        This test verifies the user was SAVED, not just created in memory.

        We test this by:
        1. Create user
        2. Query database directly for that user
        3. Verify we can find it
        """
        # Arrange
        email = "persist@test.com"

        # Act: Create user
        created_user = UserRepository.create_user(
            db_session,
            email=email,
            name="Persistence Test",
            password="test123"
        )

        # Assert: Should be able to retrieve it from database
        retrieved_user = db_session.query(User).filter(User.email == email).first()

        assert retrieved_user is not None, "User should exist in database"
        assert retrieved_user.id == created_user.id, "Should be the same user"


# =============================================================================
# TEST CLASS: User Retrieval
# =============================================================================

class TestUserRetrieval:
    """
    Tests for retrieving existing users.

    LEARNING OBJECTIVE: Testing the "Read" in CRUD
    ===============================================
    When testing retrieval, we verify:
    1. Can find existing users by various criteria (email, ID, etc.)
    2. Returns None for non-existent users (graceful failure)
    3. Returns correct user (not someone else's data!)
    4. Handles edge cases (null values, special characters, etc.)
    """

    def test_get_user_by_email_finds_existing_user(self, db_session, sample_user):
        """
        Test retrieving a user by email when they exist.

        LEARNING: Using Fixtures
        ========================
        Notice the "sample_user" parameter? That's a FIXTURE from conftest.py.
        Pytest automatically:
        1. Sees we need sample_user
        2. Runs the sample_user fixture (creates a user)
        3. Passes that user to our test

        This is cleaner than creating a user in every test!
        """
        # Arrange: sample_user fixture already created a user

        # Act: Try to find them by email
        found_user = UserRepository.get_user_by_email(db_session, sample_user.email)

        # Assert: Should find the user
        assert found_user is not None, "Should find existing user"
        assert found_user.id == sample_user.id, "Should be the same user"
        assert found_user.email == sample_user.email

    def test_get_user_by_email_returns_none_for_nonexistent(self, db_session):
        """
        Test retrieving a user who doesn't exist.

        LEARNING: Testing Negative Cases
        =================================
        Don't just test the happy path! Test what happens when things don't exist.

        Good code should:
        - Return None (not crash!)
        - Not raise exceptions for normal "not found" cases
        - Provide graceful handling

        This is called "defensive programming" - assume things might not exist.
        """
        # Arrange: No user with this email exists

        # Act: Try to find non-existent user
        found_user = UserRepository.get_user_by_email(db_session, "nonexistent@example.com")

        # Assert: Should gracefully return None
        assert found_user is None, "Should return None for non-existent user, not crash"

    def test_get_user_by_id_finds_existing_user(self, db_session):
        """
        Test retrieving a user by their database ID.

        LEARNING: Test Independence
        ============================
        This test creates its own user instead of using sample_user fixture.
        Why? To demonstrate that tests should be INDEPENDENT.

        Either approach is valid:
        - Use fixture (cleaner, less setup code)
        - Create own data (more explicit, more control)

        Choose based on what makes your test clearer!
        """
        # Arrange: Create a user
        user = UserRepository.create_user(
            db_session,
            email="findme@test.com",
            name="Find Me",
            password="test123"
        )
        user_id = user.id

        # Act: Retrieve by ID
        found_user = UserRepository.get_user_by_id(db_session, user_id)

        # Assert
        assert found_user is not None
        assert found_user.id == user_id
        assert found_user.email == "findme@test.com"

    def test_get_user_by_id_returns_none_for_invalid_id(self, db_session):
        """
        Test retrieving a user with an ID that doesn't exist.

        LEARNING: Edge Case Testing
        ============================
        What happens when we search for ID 99999 and no user has that ID?
        The function should return None, not crash.

        Always test edge cases:
        - IDs that don't exist
        - Negative IDs
        - ID of 0
        - Very large IDs
        """
        # Arrange: No user with ID 99999 exists

        # Act
        found_user = UserRepository.get_user_by_id(db_session, 99999)

        # Assert
        assert found_user is None, "Should return None for non-existent ID"


# =============================================================================
# TEST CLASS: Password Verification
# =============================================================================

class TestPasswordVerification:
    """
    Tests for password verification logic.

    LEARNING OBJECTIVE: Testing Security-Critical Functions
    ========================================================
    Password verification is CRITICAL for security. If this is broken,
    attackers can log in as anyone!

    We must test:
    1. Correct password returns True
    2. Incorrect password returns False
    3. Edge cases (empty password, wrong type, etc.)
    4. Timing attacks (not covered here, but real concern!)
    """

    def test_verify_password_returns_true_for_correct_password(self, db_session):
        """
        Test that correct password is accepted.

        LEARNING: Why Test the Obvious?
        ================================
        "Of course the correct password works!" you might think.
        But what if someone refactors verify_password and accidentally
        swaps the logic? This test catches it!

        Never assume "obvious" code works - TEST IT.
        """
        # Arrange: Create user with known password
        plain_password = "correct_horse_battery_staple"
        user = UserRepository.create_user(
            db_session,
            email="password@test.com",
            name="Password Test",
            password=plain_password
        )

        # Act: Verify with the same password
        is_valid = UserRepository.verify_password(plain_password, user.password_hash)

        # Assert: Should return True
        assert is_valid is True, \
            "Correct password should be verified successfully"

    def test_verify_password_returns_false_for_incorrect_password(self, db_session):
        """
        Test that incorrect password is rejected.

        SECURITY CRITICAL: This prevents unauthorized access!
        """
        # Arrange: Create user
        correct_password = "correct_password"
        user = UserRepository.create_user(
            db_session,
            email="security2@test.com",
            name="Security Test 2",
            password=correct_password
        )

        # Act: Try to verify with WRONG password
        wrong_password = "wrong_password"
        is_valid = UserRepository.verify_password(wrong_password, user.password_hash)

        # Assert: Should return False
        assert is_valid is False, \
            "SECURITY FAILURE: Incorrect password should NOT be accepted!"

    @pytest.mark.parametrize("wrong_password", [
        "",                    # Empty string
        "wrong",              # Completely wrong
        "Correct_password",   # Wrong case (case-sensitive!)
        "correct_password ",  # Extra space
        "orrect_password",    # Missing first character
    ])
    def test_verify_password_rejects_variations(self, db_session, wrong_password):
        """
        Test that even slight variations are rejected.

        LEARNING: Parametrized Tests
        =============================
        Notice @pytest.mark.parametrize? This runs the SAME test multiple times
        with different inputs. It's like a for-loop for tests!

        Why use parametrize?
        - Test many scenarios without code duplication (DRY!)
        - Clear to see all test cases in one place
        - Individual test results for each parameter

        The decorator means: "Run this test 5 times, once for each wrong_password value"

        When you run pytest -v, you'll see:
        - test_verify_password_rejects_variations[""]
        - test_verify_password_rejects_variations["wrong"]
        - test_verify_password_rejects_variations["Correct_password"]
        - etc.

        Each gets its own pass/fail status!
        """
        # Arrange: Create user with known password
        correct_password = "correct_password"
        user = UserRepository.create_user(
            db_session,
            email=f"param_{wrong_password[:5]}@test.com",  # Unique email for each test
            name="Param Test",
            password=correct_password
        )

        # Act: Verify with wrong password (from parametrize)
        is_valid = UserRepository.verify_password(wrong_password, user.password_hash)

        # Assert: Should all fail
        assert is_valid is False, \
            f"Password '{wrong_password}' should be rejected (not equal to '{correct_password}')"


# =============================================================================
# TEST CLASS: User Existence Check
# =============================================================================

class TestUserExistence:
    """
    Tests for checking if a user exists.

    LEARNING OBJECTIVE: Testing Boolean Functions
    ==============================================
    user_exists() returns True or False. We need to test BOTH outcomes!

    Common mistake: Only testing the True case.
    Always test: True case, False case, and edge cases.
    """

    def test_user_exists_returns_true_when_user_exists(self, db_session, sample_user):
        """
        Test that user_exists returns True for existing users.

        LEARNING: Clear Test Names
        ===========================
        The test name describes EXACTLY what we're testing:
        "user_exists returns true when user exists"

        You should be able to understand the test WITHOUT reading the code!

        Compare:
        ‚ùå Bad: test_user_exists()  (What does it test? True or False?)
        ‚úÖ Good: test_user_exists_returns_true_when_user_exists()  (Crystal clear!)
        """
        # Arrange: sample_user fixture creates a user

        # Act: Check if they exist
        exists = UserRepository.user_exists(db_session, sample_user.email)

        # Assert: Should return True
        assert exists is True, "Should return True for existing user"

    def test_user_exists_returns_false_when_user_does_not_exist(self, db_session):
        """
        Test that user_exists returns False for non-existent users.

        LEARNING: Testing Both Branches
        ================================
        This function has two possible outcomes:
        - return True (user exists)
        - return False (user doesn't exist)

        We need tests for BOTH! This is called "branch coverage" -
        ensuring every code path is tested.
        """
        # Arrange: No user with this email exists

        # Act: Check if non-existent user exists
        exists = UserRepository.user_exists(db_session, "nonexistent@example.com")

        # Assert: Should return False
        assert exists is False, "Should return False for non-existent user"

    def test_user_exists_is_case_sensitive(self, db_session, sample_user):
        """
        Test that email comparison is case-sensitive (or not, depending on design).

        LEARNING: Testing Assumptions
        ==============================
        Is "Alice@Example.com" the same as "alice@example.com"?
        It depends on your business logic!

        This test documents the expected behavior.
        If requirements change, this test will fail - which is good!
        It alerts you that behavior changed.

        NOTE: This test assumes case-sensitive comparison. If your app
        treats emails as case-insensitive, adjust this test!
        """
        # Arrange: sample_user has email "test@example.com" (lowercase)

        # Act: Search with uppercase version
        exists = UserRepository.user_exists(db_session, "TEST@EXAMPLE.COM")

        # Assert: Depending on your logic, adjust this assertion
        # Current expectation: Case-sensitive (False)
        # If case-insensitive, change to: assert exists is True
        assert exists is False, \
            "Email comparison should be case-sensitive (TEST != test)"


# =============================================================================
# TEST CLASS: Integration Tests (Multiple Operations)
# =============================================================================

@pytest.mark.integration
class TestUserWorkflows:
    """
    Integration tests for complete user workflows.

    LEARNING OBJECTIVE: Unit vs Integration Tests
    ==============================================
    UNIT TESTS (above):
    - Test ONE function in isolation
    - Fast (< 0.1 seconds each)
    - No external dependencies

    INTEGRATION TESTS (these):
    - Test MULTIPLE functions working together
    - Slower (may involve database, network, etc.)
    - Test realistic workflows

    Example: Creating a user, then immediately retrieving them.
    This tests that create AND retrieve work together correctly!

    NOTE: @pytest.mark.integration lets you run integration tests separately:
    - pytest -m unit         (run only unit tests)
    - pytest -m integration  (run only integration tests)
    - pytest                 (run all tests)
    """

    def test_create_then_retrieve_workflow(self, db_session):
        """
        Test the complete workflow: Create user ‚Üí Retrieve user ‚Üí Verify match.

        This simulates real-world usage: user signs up, then logs in.
        """
        # Step 1: Create user
        email = "workflow@test.com"
        name = "Workflow Test"
        password = "test123"

        created_user = UserRepository.create_user(db_session, email, name, password)
        assert created_user.id is not None, "User should be created with ID"

        # Step 2: Retrieve user by email
        retrieved_user = UserRepository.get_user_by_email(db_session, email)
        assert retrieved_user is not None, "Should retrieve created user"

        # Step 3: Verify it's the same user
        assert retrieved_user.id == created_user.id
        assert retrieved_user.email == created_user.email
        assert retrieved_user.name == created_user.name

    def test_complete_authentication_workflow(self, db_session):
        """
        Test the full authentication flow: Sign up ‚Üí Log in ‚Üí Verify password.

        This is a CRITICAL workflow - if this breaks, users can't log in!
        """
        # Step 1: User signs up
        email = "auth@test.com"
        password = "secure_password"

        user = UserRepository.create_user(db_session, email, "Auth Test", password)

        # Step 2: User logs in (retrieve by email)
        login_user = UserRepository.get_user_by_email(db_session, email)
        assert login_user is not None, "Should find user for login"

        # Step 3: Verify password
        password_valid = UserRepository.verify_password(password, login_user.password_hash)
        assert password_valid is True, "Correct password should authenticate user"

        # Step 4: Verify wrong password fails
        wrong_password_valid = UserRepository.verify_password("wrong", login_user.password_hash)
        assert wrong_password_valid is False, "Wrong password should fail"


# =============================================================================
# EDUCATIONAL NOTES - Testing Best Practices
# =============================================================================

"""
KEY TAKEAWAYS FROM THIS TEST FILE:
===================================

1. AAA PATTERN (Arrange-Act-Assert)
   Every test follows this structure. It makes tests readable!

2. TEST NAMES MATTER
   def test_verify_password_returns_true_for_correct_password()
   You should know what the test does WITHOUT reading it!

3. TEST BOTH POSITIVE AND NEGATIVE CASES
   - It works when it should ‚úÖ
   - It fails when it should ‚ùå
   Both matter!

4. USE FIXTURES FOR COMMON SETUP
   Instead of creating a user in every test, use sample_user fixture.

5. PARAMETRIZE FOR SIMILAR TESTS
   Test many inputs without code duplication.

6. DOCSTRINGS TEACH
   Every test has a docstring explaining:
   - What it tests
   - Why it matters
   - Key learning concepts

7. ASSERT MESSAGES HELP DEBUGGING
   assert user is not None, "User should be created"
   When the test fails, you see this message!

8. TEST SECURITY CAREFULLY
   Password hashing, authentication - these are critical!

9. INTEGRATION TESTS COMPLEMENT UNIT TESTS
   Unit tests: Does this function work?
   Integration tests: Do these functions work TOGETHER?

10. TESTS ARE DOCUMENTATION
    These tests show HOW to use UserRepository correctly.

RUNNING THESE TESTS:
====================

# Run all tests in this file:
pytest tests/unit/test_user_repository.py -v

# Run specific test:
pytest tests/unit/test_user_repository.py::TestUserCreation::test_create_user_with_valid_data -v

# Run only tests matching a pattern:
pytest tests/unit/test_user_repository.py -k "password" -v

# Show print statements:
pytest tests/unit/test_user_repository.py -s

# Stop on first failure:
pytest tests/unit/test_user_repository.py -x

# Run with coverage:
pytest tests/unit/test_user_repository.py --cov=app.repository --cov-report=html

NEXT STEPS:
===========
1. Run these tests and watch them pass! (feels good!)
2. Try breaking a test to see what failure looks like
3. Read test_giftee_repository.py for more patterns
4. Write your own tests for GiftIdeaRepository

Remember: Testing is a skill. You get better with practice! üéâ
"""
